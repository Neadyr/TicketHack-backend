var isPromise = require('is-promise')

<<<<<<< HEAD
//This file contains then/promise specific extensions to the core promise API

var Promise = require('./core.js')
var asap = require('asap')

module.exports = Promise

/* Static Functions */

function ValuePromise(value) {
  this.then = function (onFulfilled) {
    if (typeof onFulfilled !== 'function') return this
    return new Promise(function (resolve, reject) {
      asap(function () {
        try {
          resolve(onFulfilled(value))
        } catch (ex) {
          reject(ex);
        }
      })
    })
  }
}
ValuePromise.prototype = Object.create(Promise.prototype)

var TRUE = new ValuePromise(true)
var FALSE = new ValuePromise(false)
var NULL = new ValuePromise(null)
var UNDEFINED = new ValuePromise(undefined)
var ZERO = new ValuePromise(0)
var EMPTYSTRING = new ValuePromise('')

Promise.resolve = function (value) {
  if (value instanceof Promise) return value

  if (value === null) return NULL
  if (value === undefined) return UNDEFINED
  if (value === true) return TRUE
  if (value === false) return FALSE
  if (value === 0) return ZERO
  if (value === '') return EMPTYSTRING

  if (typeof value === 'object' || typeof value === 'function') {
    try {
      var then = value.then
      if (typeof then === 'function') {
        return new Promise(then.bind(value))
      }
    } catch (ex) {
      return new Promise(function (resolve, reject) {
        reject(ex)
      })
    }
  }

  return new ValuePromise(value)
}

Promise.from = Promise.cast = function (value) {
  var err = new Error('Promise.from and Promise.cast are deprecated, use Promise.resolve instead')
  err.name = 'Warning'
  console.warn(err.stack)
  return Promise.resolve(value)
}

Promise.denodeify = function (fn, argumentCount) {
  argumentCount = argumentCount || Infinity
  return function () {
    var self = this
    var args = Array.prototype.slice.call(arguments)
    return new Promise(function (resolve, reject) {
      while (args.length && args.length > argumentCount) {
        args.pop()
      }
      args.push(function (err, res) {
        if (err) reject(err)
        else resolve(res)
      })
      fn.apply(self, args)
    })
  }
}
Promise.nodeify = function (fn) {
  return function () {
    var args = Array.prototype.slice.call(arguments)
    var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null
    try {
      return fn.apply(this, arguments).nodeify(callback)
    } catch (ex) {
      if (callback === null || typeof callback == 'undefined') {
        return new Promise(function (resolve, reject) { reject(ex) })
      } else {
        asap(function () {
          callback(ex)
        })
      }
    }
  }
}

Promise.all = function () {
  var calledWithArray = arguments.length === 1 && Array.isArray(arguments[0])
  var args = Array.prototype.slice.call(calledWithArray ? arguments[0] : arguments)

  if (!calledWithArray) {
    var err = new Error('Promise.all should be called with a single array, calling it with multiple arguments is deprecated')
    err.name = 'Warning'
    console.warn(err.stack)
  }

  return new Promise(function (resolve, reject) {
    if (args.length === 0) return resolve([])
    var remaining = args.length
    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then
          if (typeof then === 'function') {
            then.call(val, function (val) { res(i, val) }, reject)
            return
          }
        }
        args[i] = val
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex)
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i])
    }
  })
}

Promise.reject = function (value) {
  return new Promise(function (resolve, reject) { 
    reject(value);
  });
}

Promise.race = function (values) {
  return new Promise(function (resolve, reject) { 
    values.forEach(function(value){
      Promise.resolve(value).then(resolve, reject);
    })
  });
}

/* Prototype Methods */

Promise.prototype.done = function (onFulfilled, onRejected) {
  var self = arguments.length ? this.then.apply(this, arguments) : this
  self.then(null, function (err) {
    asap(function () {
      throw err
    })
  })
}

Promise.prototype.nodeify = function (callback) {
  if (typeof callback != 'function') return this

  this.then(function (value) {
    asap(function () {
      callback(null, value)
    })
  }, function (err) {
    asap(function () {
      callback(err)
    })
  })
}

Promise.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
}
=======
var nextTick
if (typeof setImediate === 'function') nextTick = setImediate
else if (typeof process === 'object' && process && process.nextTick) nextTick = process.nextTick
else nextTick = function (cb) { setTimeout(cb, 0) }

var extensions = []

module.exports = Promise
function Promise(fn) {
  if (!(this instanceof Promise)) {
    return fn ? new Promise(fn) : defer()
  }
  if (typeof fn !== 'function') {
    throw new TypeError('fn is not a function')
  }

  var state = {
    isResolved: false,
    isSettled: false,
    isFulfilled: false,
    value: null,
    waiting: [],
    running: false
  }

  function _resolve(val) {
    resolve(state, val);
  }
  function _reject(err) {
    reject(state, err);
  }
  this.then = function _then(onFulfilled, onRejected) {
    return then(state, onFulfilled, onRejected);
  }

  _resolve.fulfill = deprecate(_resolve, 'resolver.fulfill(x)', 'resolve(x)')
  _resolve.reject = deprecate(_reject, 'resolver.reject', 'reject(x)')

  try {
    fn(_resolve, _reject)
  } catch (ex) {
    _reject(ex)
  }
}

function resolve(promiseState, value) {
  if (promiseState.isResolved) return
  if (isPromise(value)) {
    assimilate(promiseState, value)
  } else {
    settle(promiseState, true, value)
  }
}

function reject(promiseState, reason) {
  if (promiseState.isResolved) return
  settle(promiseState, false, reason)
}

function then(promiseState, onFulfilled, onRejected) {
  return new Promise(function (resolve, reject) {
    function done(next, skipTimeout) {
      var callback = promiseState.isFulfilled ? onFulfilled : onRejected
      if (typeof callback === 'function') {
        function timeoutDone() {
          var val
          try {
            val = callback(promiseState.value)
          } catch (ex) {
            reject(ex)
            return next(true)
          }
          resolve(val)
          next(true)
        }
        if (skipTimeout) timeoutDone()
        else nextTick(timeoutDone)
      } else if (promiseState.isFulfilled) {
        resolve(promiseState.value)
        next(skipTimeout)
      } else {
        reject(promiseState.value)
        next(skipTimeout)
      }
    }
    promiseState.waiting.push(done)
    if (promiseState.isSettled && !promiseState.running) processQueue(promiseState)
  })
}

function processQueue(promiseState) {
  function next(skipTimeout) {
    if (promiseState.waiting.length) {
      promiseState.running = true
      promiseState.waiting.shift()(next, skipTimeout)
    } else {
      promiseState.running = false
    }
  }
  next(false)
}

function settle(promiseState, isFulfilled, value) {
  if (promiseState.isSettled) return

  promiseState.isResolved = promiseState.isSettled = true
  promiseState.value = value
  promiseState.isFulfilled = isFulfilled

  processQueue(promiseState)
}

function assimilate(promiseState, thenable) {
  try {
    promiseState.isResolved = true
    thenable.then(function (res) {
      if (isPromise(res)) {
        assimilate(promiseState, res)
      } else {
        settle(promiseState, true, res)
      }
    }, function (err) {
      settle(promiseState, false, err)
    })
  } catch (ex) {
    settle(promiseState, false, ex)
  }
}

Promise.use = function (extension) {
  extensions.push(extension)
}


function deprecate(method, name, alternative) {
  return function () {
    var err = new Error(name + ' is deprecated use ' + alternative)
    if (typeof console !== 'undefined' && console && typeof console.warn === 'function') {
      console.warn(name + ' is deprecated use ' + alternative)
      if (err.stack) console.warn(err.stack)
    } else {
      nextTick(function () {
        throw err
      })
    }
    method.apply(this, arguments)
  }
}
function defer() {
  var err = new Error('promise.defer() is deprecated')
  if (typeof console !== 'undefined' && console && typeof console.warn === 'function') {
    console.warn('promise.defer() is deprecated')
    if (err.stack) console.warn(err.stack)
  } else {
    nextTick(function () {
      throw err
    })
  }
  var resolver
  var promise = new Promise(function (res) { resolver = res })
  return {resolver: resolver, promise: promise}
}
>>>>>>> cc8539d943cae2fc7b05331a7b87bb5cb43f43d4
